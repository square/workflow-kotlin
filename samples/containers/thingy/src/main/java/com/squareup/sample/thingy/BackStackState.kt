package com.squareup.sample.thingy

import com.squareup.workflow1.ui.Screen
import com.squareup.workflow1.ui.navigation.BackStackScreen
import kotlinx.coroutines.flow.MutableStateFlow

/*
TODO: Design for coalescing state updates/output emissions and dispatching
      --------------------------------------------------------------------

  Currently when something shows a thing, it creates a WorkflowAction and sends it to the action
  sink directly. onOutput does one trick to capture any emitOutput called from the UNDISPATCHED
  launch, but this is brittle and only handles some cases. And since these actions are sent in
  multiple places—i.e. replacing a workflow sends two actions: one to remove the frame when
  cancelled and one to add the new frame.

  To fix this, there is a two-part solution.

  First, actions should never be sent directly. Instead, we need a special queue object that
  accepts two things:
   - (State) -> State functions. These are used by show*Impl calls to update the stack.
   - Output values. These are sent only by emitOutput.

  This queue can then be used to collect all queued state transformations into a single action,
  along with the first-emitted output, if any. The BackStackWorkflowImpl can produce an action for
  the queue whenever it needs to:
   1. In initialState, after launching the coroutine, to get the initial state for the first render
      call and return from initialState.
   2. In onPropsUpdated, to collect any state changes effected by pushing the new props value into
      the flow and return it from onPropsUpdated.
   3. In a workflow's outputHandler, to collect the immediate set of updates generated by the
      output handler and return an action to bubble up the action cascade.

  The second part is a special CoroutineDispatcher, similar to WorkStealingDispatcher, that can be
  drained at any time. The API (in addition to basic CoroutineDispatcher stuff) should look
  something like this:

  internal class BackStackDispatcher: CoroutineDispatcher() {
    …

    /**
 * Suspends indefinitely, handling any dispatch calls that aren't inside a [runThenDrain] by
 * dispatching to the dispatcher from the current context. After processing at least one task,
 * when there are no more tasks enqueued, calls [onIdle].
 */
    suspend fun run(onIdle: () -> Unit)

    /**
 * Runs [block] such that any tasks that are dispatched to this dispatcher by [block] are not
 * dispatched like normal, but collected into a special queue and all ran after [block] returns
 * but before this function returns. I.e. any coroutine work started by [block] is guaranteed to
 * be have been run and the dispatcher will be idle when this function returns.
 */
    fun runThenDrain(block: () -> Unit)
  }

  This dispatcher can then be used inside the BackStackWorkflowImpl functions mentioned above to
  ensure all coroutines run before collecting state transformations. E.g.

  override fun initialState(…): BackStackState {
    dispatcher.runThenDrain {
      scope.launch { runBackStack(…) }
    }
    val initialStack = actionQueue.consumeAllStateTransformations()
    …
    return BackStackState(frames = initialStack, dispatcher = dispatcher, actions = actionQueue)
  }

  Inside render, `run` can be used to support normal dispatching:

  context.runningSideEffect {
    state.dispatcher.run(onIdle = {
      // Only returns >1 action if multiple emitOutput calls happened. All state transformations
      // will always be in the first one. Returns an empty list if no state transforms or outputs
      // were enqueued.
      val actions = state.actionQueue.consumeAsActions()
      actions.forEach {
        context.actionSink.send(it)
      }
    })
  }

  To ensure all show*Impl calls get processed by this idle handler, they need to always internally
  make sure they're running on the special dispatcher.

  All this dispatcher/action queue coordination should be encapsulated inside the BackStackState.
*/

// Impl note: Does some casting to avoid dealing with generics everywhere, since this is internal-
// only. Can we use this trick in more places?
internal class BackStackState(
  private val stack: List<BackStackFrame<*>>,
  private val props: MutableStateFlow<Any?>,
  private val backStackFactory: BackStackFactory,
) {

  fun copy(stack: List<BackStackFrame<*>> = this.stack) = BackStackState(
    stack = stack,
    props = props,
    backStackFactory = backStackFactory,
  )

  fun setProps(props: Any?) {
    this.props.value = props
  }

  fun appendFrame(frame: BackStackFrame<*>) = copy(stack = stack + frame)
  fun removeFrame(frame: BackStackFrame<*>) = copy(stack = stack - frame)

  fun popToFrame(frame: BackStackFrame<*>): BackStackState {
    val index = stack.indexOf(frame)
    check(index != -1) { "Frame was not in the stack!" }

    // Cancel all the frames we're about to drop, starting from the top.
    for (i in stack.lastIndex downTo index + 1) {
      // Don't just cancel the frame job, since that would only cancel output handlers the frame
      // is running. We want to cancel the whole parent's output handler that called showWorkflow,
      // in case the showWorkflow is in a try/catch that tries to make other suspending calls.
      stack[i].cancelCaller()
    }

    val newStack = stack.take(index + 1)
    return copy(stack = newStack)
  }

  fun <ChildPropsT> setFrameProps(
    frame: WorkflowFrame<*, *, ChildPropsT, *, *>,
    newProps: ChildPropsT
  ): BackStackState {
    val stack = stack.toMutableList()
    val myIndex = stack.indexOf(frame)
    if (myIndex == -1) {
      // Frame has been removed from the stack, so just no-op.
      return this
    }
    stack[myIndex] = frame.copy(props = newProps)
    return copy(stack = stack)
  }

  inline fun <R> mapFrames(block: (BackStackFrame<*>) -> R): List<R> = stack.map(block)

  fun createBackStack(screens: List<Screen>): BackStackScreen<Screen> =
    // TODO pass isTopIdle
    backStackFactory.createBackStack(screens, isTopIdle = false)
}
