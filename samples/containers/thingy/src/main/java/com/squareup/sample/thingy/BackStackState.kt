package com.squareup.sample.thingy

import com.squareup.workflow1.StatefulWorkflow.RenderContext
import com.squareup.workflow1.WorkflowAction
import com.squareup.workflow1.ui.Screen
import com.squareup.workflow1.ui.navigation.BackStackScreen
import kotlinx.coroutines.flow.MutableStateFlow

/*
TODO: Design for coalescing state updates/output emissions and dispatching
      --------------------------------------------------------------------

  Currently when something shows a thing, it creates a WorkflowAction and sends it to the action
  sink directly. onOutput does one trick to capture any emitOutput called from the UNDISPATCHED
  launch, but this is brittle and only handles some cases. And since these actions are sent in
  multiple places—i.e. replacing a workflow sends two actions: one to remove the frame when
  cancelled and one to add the new frame.

  To fix this, there is a two-part solution.

  First, actions should never be sent directly. Instead, we need a special queue object that
  accepts two things:
   - (State) -> State functions. These are used by show*Impl calls to update the stack.
   - Output values. These are sent only by emitOutput.

  This queue can then be used to collect all queued state transformations into a single action,
  along with the first-emitted output, if any. The BackStackWorkflowImpl can produce an action for
  the queue whenever it needs to:
   1. In initialState, after launching the coroutine, to get the initial state for the first render
      call and return from initialState.
   2. In onPropsUpdated, to collect any state changes effected by pushing the new props value into
      the flow and return it from onPropsUpdated.
   3. In a workflow's outputHandler, to collect the immediate set of updates generated by the
      output handler and return an action to bubble up the action cascade.

  The second part is a special CoroutineDispatcher, similar to WorkStealingDispatcher, that can be
  drained at any time. The API (in addition to basic CoroutineDispatcher stuff) should look
  something like this:

  internal class BackStackDispatcher: CoroutineDispatcher() {
    …

    /**
 * Suspends indefinitely, handling any dispatch calls that aren't inside a [runThenDrain] by
 * dispatching to the dispatcher from the current context. After processing at least one task,
 * when there are no more tasks enqueued, calls [onIdle].
 */
    suspend fun run(onIdle: () -> Unit)

    /**
 * Runs [block] such that any tasks that are dispatched to this dispatcher by [block] are not
 * dispatched like normal, but collected into a special queue and all ran after [block] returns
 * but before this function returns. I.e. any coroutine work started by [block] is guaranteed to
 * be have been run and the dispatcher will be idle when this function returns.
 */
    fun runThenDrain(block: () -> Unit)
  }

  This dispatcher can then be used inside the BackStackWorkflowImpl functions mentioned above to
  ensure all coroutines run before collecting state transformations. E.g.

  override fun initialState(…): BackStackState {
    dispatcher.runThenDrain {
      scope.launch { runBackStack(…) }
    }
    val initialStack = actionQueue.consumeAllStateTransformations()
    …
    return BackStackState(frames = initialStack, dispatcher = dispatcher, actions = actionQueue)
  }

  Inside render, `run` can be used to support normal dispatching:

  context.runningSideEffect {
    state.dispatcher.run(onIdle = {
      // Only returns >1 action if multiple emitOutput calls happened. All state transformations
      // will always be in the first one. Returns an empty list if no state transforms or outputs
      // were enqueued.
      val actions = state.actionQueue.consumeAsActions()
      actions.forEach {
        context.actionSink.send(it)
      }
    })
  }

  To ensure all show*Impl calls get processed by this idle handler, they need to always internally
  make sure they're running on the special dispatcher.

  All this dispatcher/action queue coordination should be encapsulated inside the BackStackState.
*/

// Impl note: Does some casting to avoid dealing with generics everywhere, since this is internal-
// only.
internal class BackStackState(
  private val stack: List<BackStackFrame>,
  private val props: MutableStateFlow<Any?>,
  private val backStackFactory: BackStackFactory,
  private val actionQueue: ActionQueue,
  private val dispatcher: BackStackDispatcher,
) {

  fun setProps(props: Any?): BackStackState {
    dispatcher.runThenDispatchImmediately {
      this.props.value = props
    }

    val mutableStack = stack.toMutableList()
    actionQueue.consumeActionsToStack(mutableStack)
    return copy(stack = mutableStack)
  }

  fun renderOn(context: RenderContext<Any?, BackStackState, Any?>): BackStackScreen<Screen> {
    context.runningSideEffect("TODO") {
      dispatcher.runDispatch(onIdle = {
        sendActionToSink(context)
      })
    }

    val renderings = stack.map { frame ->
      frame.render(context)
    }
    return backStackFactory.createBackStack(renderings, isTopIdle = false)
  }

  fun transformStack(transformations: List<StateTransformation>): BackStackState {
    val mutableStack = stack.toMutableList()
    transformations.forEach {
      it(mutableStack)
    }
    return copy(stack = mutableStack)
  }

  private fun sendActionToSink(context: RenderContext<Any?, BackStackState, Any?>) {
    @Suppress("UNCHECKED_CAST")
    context.actionSink.send(
      actionQueue.consumeToAction { sendActionToSink(context) } as
        WorkflowAction<Any?, BackStackState, Any?>
    )
  }

  private fun copy(stack: List<BackStackFrame> = this.stack) = BackStackState(
    stack = stack,
    props = props,
    backStackFactory = backStackFactory,
    actionQueue = actionQueue,
    dispatcher = dispatcher,
  )
}
